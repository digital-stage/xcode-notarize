{"version":3,"file":"index.js","mappings":";;;;;;AAAA;;;;;;;;AAAA;;;;;;;;AAAA;;;;;;;;;ACAA;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC7BA;AACA;;;;;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["../webpack://xcode-notarize/../../../../../opt/homebrew/Cellar/ncc/0.36.1/libexec/lib/node_modules/@vercel/ncc/dist/ncc/@@notfound.js","../webpack://xcode-notarize/external node-commonjs \"fs\"","../webpack://xcode-notarize/webpack/bootstrap","../webpack://xcode-notarize/webpack/runtime/compat","../webpack://xcode-notarize/./index.js"],"sourcesContent":[null,"module.exports = require(\"fs\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\tvar threw = true;\n\ttry {\n\t\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\t\tthrew = false;\n\t} finally {\n\t\tif(threw) delete __webpack_module_cache__[moduleId];\n\t}\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","\nif (typeof __webpack_require__ !== 'undefined') __webpack_require__.ab = __dirname + \"/\";","// MIT License - Copyright (c) 2020 Stefan Arentz <stefan@devbots.xyz>\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\n\nconst fs = require('fs');\n\nconst core = require('@actions/core');\nconst execa = require('execa');\nconst plist = require('plist');\n\n\nconst sleep = (ms) => {\n    return new Promise(res => setTimeout(res, ms));\n};\n\n\nconst parseConfiguration = () => {\n    const configuration = {\n        productPath: core.getInput(\"product-path\", {required: true}),\n        username: core.getInput(\"appstore-connect-username\", {required: true}),\n        password: core.getInput(\"appstore-connect-password\", {required: true}),\n        primaryBundleId: core.getInput(\"primary-bundle-id\"),\n        verbose: core.getInput(\"verbose\") === \"true\",\n    };\n\n    if (!fs.existsSync(configuration.productPath)) {\n        throw Error(`Product path ${configuration.productPath} does not exist.`);\n    }\n\n    return configuration\n};\n\n\nconst archive = async ({productPath}) => {\n    const archivePath = \"/tmp/archive.zip\"; // TODO Temporary file\n\n    const args = [\n        \"-c\",           // Create an archive at the destination path\n        \"-k\",           // Create a PKZip archive\n        \"--keepParent\", // Embed the parent directory name src in dst_archive.\n        productPath,    // Source\n        archivePath,    // Destination\n    ];\n\n    try {\n        await execa(\"ditto\", args);\n    } catch (error) {\n        core.error(error);\n        return null;\n    }\n\n    return archivePath;\n};\n\n\nconst submit = async ({productPath, archivePath, primaryBundleId, username, password, verbose}) => {\n    //\n    // Make sure the product exists.\n    //\n\n    if (!fs.existsSync(productPath)) {\n        throw Error(`No product could be found at ${productPath}`);\n    }\n\n    //\n    // The notarization process requires us to submit a 'primary\n    // bundle id' - this is just a unique identifier for notarizing\n    // this specific product. If it is not provided then we simply\n    // use the actual bundle identifier from the Info.plist\n    //\n\n    if (primaryBundleId === \"\") {\n        const path = productPath + \"/Contents/Info.plist\";\n        if (fs.existsSync(path)) {\n            const info = plist.parse(fs.readFileSync(path, \"utf8\"));\n            primaryBundleId = info.CFBundleIdentifier;\n        }\n    }\n\n    if (primaryBundleId === null) {\n        throw Error(\"No primary-bundle-id set and could not determine bundle identifier from product.\");\n    }\n\n    //\n    // Run altool to notarize this application. This only submits the\n    // application to the queue on Apple's server side. It does not\n    // actually tell us if the notarization was succesdful or not, for\n    // that we need to poll using the request UUID that is returned.\n    //\n\n    const args = [\n        \"altool\",\n        \"--output-format\", \"json\",\n        \"--notarize-app\",\n        \"-f\", archivePath,\n        \"--primary-bundle-id\", primaryBundleId,\n        \"-u\", username,\n        \"-p\", password\n    ];\n\n    if (verbose === true) {\n        args.push(\"--verbose\");\n    }\n\n    let xcrun = execa(\"xcrun\", args, {reject: false});\n\n    if (verbose == true) {\n        xcrun.stdout.pipe(process.stdout);\n        xcrun.stderr.pipe(process.stderr);\n    }\n\n    const {exitCode, stdout, stderr} = await xcrun;\n\n    if (exitCode === undefined) {\n        // TODO Command did not run at all\n        throw Error(\"Unknown failure - altool did not run at all?\");\n    }\n\n    if (exitCode !== 0) {\n        // TODO Maybe print stderr - see where that ends up in the output? console.log(\"STDERR\", stderr);\n        const response = JSON.parse(stdout);\n        if (verbose === true) {\n            console.log(response);\n        }\n\n        for (const productError of response[\"product-errors\"]) {\n            core.error(`${productError.code} - ${productError.message}`);\n        }\n        return null;\n    }\n\n    const response = JSON.parse(stdout);\n    if (verbose === true) {\n        console.log(response);\n    }\n\n    return response[\"notarization-upload\"][\"RequestUUID\"];\n};\n\n\nconst wait = async ({uuid, username, password, verbose}) => {\n    const args = [\n        \"altool\",\n        \"--output-format\", \"json\",\n        \"--notarization-info\",\n        uuid,\n        \"-u\", username,\n        \"-p\", password\n    ];\n\n    if (verbose === true) {\n        args.push(\"--verbose\");\n    }\n\n    for (let i = 0; i < 10; i++) {\n        let xcrun = execa(\"xcrun\", args, {reject: false});\n\n        if (verbose == true) {\n            xcrun.stdout.pipe(process.stdout);\n            xcrun.stderr.pipe(process.stderr);\n        }\n\n        const {exitCode, stdout, stderr} = await xcrun;\n\n        if (exitCode === undefined) {\n            // TODO Command did not run at all\n            throw Error(\"Unknown failure - altool did not run at all?\");\n        }\n\n        if (exitCode !== 0) {\n            // TODO Maye print stderr - see where that ends up in the output? console.log(\"STDERR\", stderr);\n            const response = JSON.parse(stdout);\n            if (verbose === true) {\n                console.log(response);\n            }\n\n            for (const productError of response[\"product-errors\"]) {\n                core.error(`${productError.code} - ${productError.message}`);\n            }\n            return false;\n        }\n\n        const response = JSON.parse(stdout);\n        if (verbose === true) {\n            console.log(response);\n        }\n\n        const notarizationInfo = response[\"notarization-info\"];\n        switch (notarizationInfo[\"Status\"]) {\n            case \"in progress\":\n                core.info(`Notarization status <in progress>`);\n                break;\n            case \"invalid\":\n                core.error(`Notarization status <invalid> - ${notarizationInfo[\"Status Message\"]}`);\n                return false;\n            case \"success\":\n                core.info(`Notarization status <success>`);\n                return true;\n            default:\n                core.error(`Notarization status <${notarizationInfo[\"Status\"]}> - TODO`);\n                return false;\n        }\n\n        await sleep(30000);\n    }\n\n    core.error(\"Failed to get final notarization status on time.\");\n\n    return false;\n};\n\nconst main = async () => {\n    try {\n        const configuration = parseConfiguration();\n\n        const archivePath = await core.group('Archiving Application', async () => {\n            const archivePath = await archive(configuration)\n            if (archivePath !== null) {\n                core.info(`Created application archive at ${archivePath}`);\n            }\n            return archivePath;\n        });\n\n        if (archivePath == null) {\n            core.setFailed(\"Notarization failed\");\n            return;\n        }\n\n        const uuid = await core.group('Submitting for Notarizing', async () => {\n            let uuid = await submit({archivePath: archivePath, ...configuration});\n            if (uuid !== null) {\n                core.info(`Submitted package for notarization. Request UUID is ${uuid}`);\n            }\n            return uuid;\n        });\n\n        if (uuid == null) {\n            core.setFailed(\"Notarization failed\");\n            return;\n        }\n\n        await sleep(15000); // TODO On a busy day, it can take a while before the build can be checked?\n\n        const success = await core.group('Waiting for Notarization Status', async () => {\n            return await wait({uuid: uuid, archivePath: archivePath, ...configuration})\n        });\n\n        if (success == false) {\n            core.setFailed(\"Notarization failed\");\n            return;\n        }\n\n        core.setOutput('product-path', configuration.productPath);\n    } catch (error) {\n        core.setFailed(`Notarization failed with an unexpected error: ${error.message}`);\n    }\n};\n\n\nmain();\n"],"names":[],"sourceRoot":""}